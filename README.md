# quint-konnect

A Kotlin library for model-based testing (MBT) with [Quint](https://github.com/informalsystems/quint) formal specifications. It replays execution traces generated by the `quint` CLI against your Kotlin code to verify behavioral equivalence.

This is a Kotlin port of [quint-connect](https://github.com/informalsystems/quint-connect) (Rust).

## How it works

```
Quint Spec → [quint CLI] → ITF trace files → quint-konnect → your Kotlin code
```

1. You annotate a *driver* class with `@QuintRun` or `@QuintTest`.
2. KSP generates a JUnit 5 test class and a `generatedStep()` dispatcher at compile time.
3. At test runtime, the library invokes the `quint` CLI to generate randomized traces from your spec.
4. Each trace step is replayed against your driver. Optionally, state is compared after every step.

## Quick start

### 1. Add dependencies

```kotlin
// build.gradle.kts
dependencies {
    implementation(project(":core"))
    kspTest(project(":ksp"))
    testImplementation(project(":core"))
    testImplementation(libs.kotlinx.serialization.json)
    testImplementation(libs.junit5.api)
    testRuntimeOnly(libs.junit5.engine)
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

kotlin {
    sourceSets.test {
        kotlin.srcDir("build/generated/ksp/test/kotlin")
    }
}
```

Requires `quint` in `PATH`.

### 2. Write your driver
The driver is a class annotated with `@QuintRun` or `@QuintTest` and implements `Driver` from `quint-konnect`.

```kotlin
// src/test/kotlin/
@QuintRun(spec = "src/test/resources/my.qnt", maxSamples = 10)
class MyDriver : Driver {
    override fun step(step: Step) = generatedStep(step)
    override fun quintState(): State<*> = MyState()

    @QuintAction("init")
    fun init() { /* reset implementation state */ }

    @QuintAction("Move")
    fun move(position: List<Long>) { /* execute move */ }

    @QuintAction("Undo")
    fun undo(position: List<Long>?) { /* nullable = optional nondet pick */ }
}
```

KSP generates `MyDriver.generatedStep(step)`, which dispatches to the right method based on `step.actionTaken`.

### 3. Implement state checking (optional)

```kotlin
@Serializable
data class MySpecState(val count: Long)

class MyState : TypedState<MyDriver, MySpecState>(serializer()) {
    override fun extractFromDriver(driver: MyDriver): MySpecState {
        return MySpecState(count = driver.counter)
    }
}
```

The framework deserializes the spec state from the ITF trace and compares it with `extractFromDriver()` using `equals()` after each step.

### 4. Run

```bash
./gradlew :mymodule:test
```

## Annotations

| Annotation | Target | Purpose |
|---|---|---|
| `@QuintRun(spec, ...)` | class | Generates traces via `quint run --mbt` |
| `@QuintTest(spec, test, ...)` | class | Generates traces via `quint test --match` |
| `@QuintAction("Name")` | method | Maps a Quint action to a driver method |

`@QuintRun` / `@QuintTest` parameters:

| Parameter | Type | Default | Description |
|---|---|---|---|
| `spec` | String | required | Path to the `.qnt` spec file |
| `main` | String | `""` | Quint module name (if not inferred) |
| `init` | String | `""` | Init action override |
| `step` | String | `""` | Step action override |
| `maxSamples` | Int | 5 | Number of traces to generate |
| `maxSteps` | Int | -1 | Max steps per trace (unlimited if -1) |
| `seed` | String | `""` | Fixed seed for reproducibility |

## Representing Quint types in Kotlin

| Quint type | Kotlin `@Serializable` type |
|---|---|
| `int` | `Long` |
| `bool` | `Boolean` |
| `str` | `String` |
| `(int, int)` tuple | `List<Long>` (index 0 = `._1`, index 1 = `._2`) |
| `int -> V` map | `Map<Long, V>` |
| `Set[T]` | `List<T>` |
| `type P = X \| O` sum type | `@Serializable @JsonClassDiscriminator("tag") sealed class` |
| `type S = Foo(P) \| Bar` | sealed class with `data class Foo(val value: P)` and `object Bar` |

For sum types, add `@file:OptIn(ExperimentalSerializationApi::class)` at the top of the file.

## ITF (Informal Trace Format)

ITF is the JSON format used by Quint and [Apalache](https://apalache-mc.org) to encode execution traces. Because JSON has fewer types than Quint, ITF uses `#`-prefixed object keys as type tags:

| ITF JSON | Quint type | `ItfValue` variant |
|---|---|---|
| `true` / `false` | `bool` | `ItfValue.Bool` |
| `42` | `int` (fits in 64 bits) | `ItfValue.Num` |
| `"hello"` | `str` | `ItfValue.Str` |
| `{"#bigint": "123"}` | `int` (arbitrary precision) | `ItfValue.BigInt` |
| `[1, 2, 3]` | `List[int]` | `ItfValue.List` |
| `{"#tup": [1, 2]}` | `(int, int)` | `ItfValue.Tup` |
| `{"#set": [1, 2]}` | `Set[int]` | `ItfValue.Set` |
| `{"#map": [[k, v], ...]}` | `int -> V` | `ItfValue.Map` |
| `{"field": ...}` | record or sum-type variant | `ItfValue.Record` |

In MBT mode, each ITF state includes two special variables under the `mbt` namespace:

- `mbt::actionTaken` — name of the Quint action that produced this state
- `mbt::nondetPicks` — record of nondeterministic choices made during the action

The library reads these to dispatch to the correct driver method and deserialize the method parameters.

## Environment variables

| Variable | Values | Description |
|---|---|---|
| `QUINT_VERBOSE` | `0` (default), `1`, `2` | `1` logs each trace and step; `2` also dumps raw ITF state |
| `QUINT_SEED` | hex string, e.g. `0xdeadbeef` | Fixes the random seed for reproducible runs |

```bash
QUINT_VERBOSE=1 ./gradlew :example:test
QUINT_SEED=0x1234 ./gradlew :example:test
```

## Modules

| Module | Description |
|---|---|
| `annotations` | Annotation declarations only. No runtime dependency. |
| `core` | Runtime: ITF parsing, trace generation, step extraction, state comparison, runner. |
| `ksp` | KSP2 processor. Generates `generatedStep()` and JUnit 5 test classes. |
| `example` | TicTacToe end-to-end example. |

## Example

See [`example/`](./example) for a complete TicTacToe example:
- [`TicTacToe.kt`](example/src/main/kotlin/io/github/mcbianconi/quintkonnect/example/tictactoe/TicTacToe.kt) — game logic
- [`TicTacToeDriver.kt`](example/src/test/kotlin/io/github/mcbianconi/quintkonnect/example/tictactoe/TicTacToeDriver.kt) — annotated driver
- [`GameState.kt`](example/src/test/kotlin/io/github/mcbianconi/quintkonnect/example/tictactoe/GameState.kt) — state comparison
- [`tictactoe.qnt`](example/src/test/resources/tictactoe.qnt) — Quint specification

## Build & test

```bash
./gradlew :annotations:build         # Build annotation declarations
./gradlew :core:test                 # Run core unit tests (no quint CLI required)
./gradlew :ksp:build                 # Build KSP processor
./gradlew :example:build             # Build example + run end-to-end test (requires quint in PATH)
./gradlew build                      # Build all modules
```
